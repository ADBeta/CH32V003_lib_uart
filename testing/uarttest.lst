
uarttest.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <InterruptVector>:
void InterruptVector()         __attribute__((naked)) __attribute((section(".init"))) __attribute((weak,alias("InterruptVectorDefault")));
void InterruptVectorDefault()  __attribute__((naked)) __attribute((section(".init")));

void InterruptVectorDefault()
{
	asm volatile( "\n\
   0:	0f60006f          	j	f6 <handle_reset>
   4:	00000000          	.word	0x00000000
   8:	0000016e          	.word	0x0000016e
   c:	0000016c          	.word	0x0000016c
	...
  30:	0000016c          	.word	0x0000016c
  34:	00000000          	.word	0x00000000
  38:	0000016c          	.word	0x0000016c
  3c:	00000000          	.word	0x00000000
  40:	0000016c          	.word	0x0000016c
  44:	0000016c          	.word	0x0000016c
  48:	0000016c          	.word	0x0000016c
  4c:	0000016c          	.word	0x0000016c
  50:	0000016c          	.word	0x0000016c
  54:	0000016c          	.word	0x0000016c
  58:	0000016c          	.word	0x0000016c
  5c:	0000016c          	.word	0x0000016c
  60:	0000016c          	.word	0x0000016c
  64:	0000016c          	.word	0x0000016c
  68:	0000016c          	.word	0x0000016c
  6c:	0000016c          	.word	0x0000016c
  70:	0000016c          	.word	0x0000016c
  74:	0000016c          	.word	0x0000016c
  78:	0000016c          	.word	0x0000016c
  7c:	0000016c          	.word	0x0000016c
  80:	000002aa          	.word	0x000002aa
  84:	0000016c          	.word	0x0000016c
  88:	0000016c          	.word	0x0000016c
  8c:	0000016c          	.word	0x0000016c
  90:	0000016c          	.word	0x0000016c
  94:	0000016c          	.word	0x0000016c
  98:	0000016c          	.word	0x0000016c
  9c:	0000                	unimp
	...

Disassembly of section .text:

000000a0 <uart_print.part.0>:
	{
		// TODO: Set ret to not finished
		while(*string != '\0')
		{
			// Wait for the current transmission to finish
			while(!(USART1->STATR & USART_FLAG_TC));
  a0:	400147b7          	lui	a5,0x40014
  a4:	80078793          	addi	a5,a5,-2048 # 40013800 <__global_pointer$+0x20013000>
		while(*string != '\0')
  a8:	00054683          	lbu	a3,0(a0)
  ac:	e299                	bnez	a3,b2 <uart_print.part.0+0x12>
		}
		ret_err = UART_OK;
	}

	return ret_err;
}
  ae:	4501                	li	a0,0
  b0:	8082                	ret
			while(!(USART1->STATR & USART_FLAG_TC));
  b2:	0007d703          	lhu	a4,0(a5)
  b6:	04077713          	andi	a4,a4,64
  ba:	df65                	beqz	a4,b2 <uart_print.part.0+0x12>
			USART1->DATAR = *string++;
  bc:	0505                	addi	a0,a0,1
  be:	00d79223          	sh	a3,4(a5)
  c2:	b7dd                	j	a8 <uart_print.part.0+0x8>

000000c4 <uart_println.part.0>:
	uart_err_t ret_err = uart_print(string);
	
	if(ret_err == UART_OK)
	{
		// Print the terminating characters
		while(!(USART1->STATR & USART_FLAG_TC));
  c4:	400147b7          	lui	a5,0x40014
  c8:	80078793          	addi	a5,a5,-2048 # 40013800 <__global_pointer$+0x20013000>
  cc:	0007d703          	lhu	a4,0(a5)
  d0:	04077713          	andi	a4,a4,64
  d4:	df65                	beqz	a4,cc <uart_println.part.0+0x8>
		USART1->DATAR = '\r';
  d6:	4735                	li	a4,13
  d8:	00e79223          	sh	a4,4(a5)
		while(!(USART1->STATR & USART_FLAG_TC));
  dc:	400147b7          	lui	a5,0x40014
  e0:	80078793          	addi	a5,a5,-2048 # 40013800 <__global_pointer$+0x20013000>
  e4:	0007d703          	lhu	a4,0(a5)
  e8:	04077713          	andi	a4,a4,64
  ec:	df65                	beqz	a4,e4 <uart_println.part.0+0x20>
		USART1->DATAR = '\n';
  ee:	4729                	li	a4,10
  f0:	00e79223          	sh	a4,4(a5)
	}

	return ret_err;
}
  f4:	8082                	ret

000000f6 <handle_reset>:
	asm volatile( ".option   pop;\n");
}

void handle_reset()
{
	asm volatile( "\n\
  f6:	20000197          	auipc	gp,0x20000
  fa:	70a18193          	addi	gp,gp,1802 # 20000800 <__global_pointer$>
  fe:	00018113          	mv	sp,gp
 102:	08000513          	li	a0,128
 106:	30051073          	csrw	mstatus,a0
 10a:	468d                	li	a3,3
 10c:	00000517          	auipc	a0,0x0
 110:	ef450513          	addi	a0,a0,-268 # 0 <InterruptVector>
 114:	8d55                	or	a0,a0,a3
 116:	30551073          	csrw	mtvec,a0
	csrw mtvec, a0\n" 
	: : : "a0", "a3", "memory");

	// Careful: Use registers to prevent overwriting of self-data.
	// This clears out BSS.
asm volatile(
 11a:	20000517          	auipc	a0,0x20000
 11e:	ee650513          	addi	a0,a0,-282 # 20000000 <_uart_rx_buffer>
 122:	83418593          	addi	a1,gp,-1996 # 20000034 <_ebss>
 126:	4601                	li	a2,0
 128:	00b55663          	bge	a0,a1,134 <handle_reset+0x3e>
 12c:	c110                	sw	a2,0(a0)
 12e:	0511                	addi	a0,a0,4
 130:	feb54ee3          	blt	a0,a1,12c <handle_reset+0x36>
 134:	37400513          	li	a0,884
 138:	20000597          	auipc	a1,0x20000
 13c:	ec858593          	addi	a1,a1,-312 # 20000000 <_uart_rx_buffer>
 140:	20000617          	auipc	a2,0x20000
 144:	ec060613          	addi	a2,a2,-320 # 20000000 <_uart_rx_buffer>
 148:	00c58863          	beq	a1,a2,158 <handle_reset+0x62>
 14c:	4114                	lw	a3,0(a0)
 14e:	c194                	sw	a3,0(a1)
 150:	0511                	addi	a0,a0,4
 152:	0591                	addi	a1,a1,4
 154:	fec59ae3          	bne	a1,a2,148 <handle_reset+0x52>
: : : "a0", "a1", "a2", "a3", "memory"
#endif
);

#if defined( FUNCONF_SYSTICK_USE_HCLK ) && FUNCONF_SYSTICK_USE_HCLK
	SysTick->CTLR = 5;
 158:	e000f7b7          	lui	a5,0xe000f
 15c:	4715                	li	a4,5
 15e:	c398                	sw	a4,0(a5)
#else
	SysTick->CTLR = 1;
#endif

	// set mepc to be main as the root app.
asm volatile(
 160:	1d000793          	li	a5,464
 164:	34179073          	csrw	mepc,a5
 168:	30200073          	mret

0000016c <ADC1_IRQHandler>:
	asm volatile( "1: j 1b" );
 16c:	a001                	j	16c <ADC1_IRQHandler>

0000016e <NMI_Handler>:
	RCC->INTR |= RCC_CSSC;	// clear the clock security int flag
 16e:	40021737          	lui	a4,0x40021
 172:	471c                	lw	a5,8(a4)
 174:	008006b7          	lui	a3,0x800
 178:	8fd5                	or	a5,a5,a3
 17a:	c71c                	sw	a5,8(a4)

0000017c <SystemInit>:
	// CH32V003 flash latency
#if defined(CH32X03x)
	FLASH->ACTLR = FLASH_ACTLR_LATENCY_2;                   // +2 Cycle Latency (Recommended per TRM)
#elif defined(CH32V003)
	#if FUNCONF_SYSTEM_CORE_CLOCK > 25000000
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;               // +1 Cycle Latency
 17c:	400227b7          	lui	a5,0x40022
 180:	4705                	li	a4,1
 182:	c398                	sw	a4,0(a5)
#if defined(FUNCONF_USE_HSI) && FUNCONF_USE_HSI
	#if defined(CH32V30x) || defined(CH32V20x) || defined(CH32V10x)
		EXTEN->EXTEN_CTR |= EXTEN_PLL_HSI_PRE;
	#endif
	#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
		RCC->CFGR0 = BASE_CFGR0;
 184:	400217b7          	lui	a5,0x40021
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 188:	01080737          	lui	a4,0x1080
		RCC->CFGR0 = BASE_CFGR0;
 18c:	0007a223          	sw	zero,4(a5) # 40021004 <__global_pointer$+0x20020804>
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 190:	08170713          	addi	a4,a4,129 # 1080081 <lib_uart.c.4f521083+0x107df46>
 194:	c398                	sw	a4,0(a5)
	#else
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;       		// +1 Cycle Latency
	#endif
#endif

	RCC->INTR  = 0x009F0000;                               // Clear PLL, CSSC, HSE, HSI and LSI ready flags.
 196:	009f0737          	lui	a4,0x9f0
 19a:	c798                	sw	a4,8(a5)

#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
	while((RCC->CTLR & RCC_PLLRDY) == 0);                       	// Wait till PLL is ready
 19c:	4398                	lw	a4,0(a5)
 19e:	00671693          	slli	a3,a4,0x6
 1a2:	fe06dde3          	bgez	a3,19c <SystemInit+0x20>
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 1a6:	43d8                	lw	a4,4(a5)
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 1a8:	400216b7          	lui	a3,0x40021
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 1ac:	9b71                	andi	a4,a4,-4
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
 1ae:	00276713          	ori	a4,a4,2
 1b2:	c3d8                	sw	a4,4(a5)
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 1b4:	4721                	li	a4,8
 1b6:	42dc                	lw	a5,4(a3)
 1b8:	8bb1                	andi	a5,a5,12
 1ba:	fee79ee3          	bne	a5,a4,1b6 <SystemInit+0x3a>
	*DMDATA1 = 0x0;
 1be:	e00007b7          	lui	a5,0xe0000
 1c2:	0e07ac23          	sw	zero,248(a5) # e00000f8 <__global_pointer$+0xbffff8f8>
	*DMDATA0 = 0x80;
 1c6:	08000713          	li	a4,128
 1ca:	0ee7aa23          	sw	a4,244(a5)
	SetupUART( UART_BRR );
#endif
#if defined( FUNCONF_USE_DEBUGPRINTF ) && FUNCONF_USE_DEBUGPRINTF
	SetupDebugPrintf();
#endif
}
 1ce:	8082                	ret

000001d0 <main>:
// The UART RX Ring Buffer (Must be > 0. Must be a Power of 2)
uint8_t buff[32] = {0};
uint8_t uart_rx_buffer[32] = {0x00};

int main()
{
 1d0:	1171                	addi	sp,sp,-4
 1d2:	c006                	sw	ra,0(sp)
	SystemInit();
 1d4:	3765                	jal	17c <SystemInit>
	_uart_rx_buffer.buffer = (uint8_t *)rx_buffer_ptr;
 1d6:	200007b7          	lui	a5,0x20000
 1da:	20000737          	lui	a4,0x20000
 1de:	00078793          	mv	a5,a5
 1e2:	01470713          	addi	a4,a4,20 # 20000014 <uart_rx_buffer>
 1e6:	c398                	sw	a4,0(a5)
	_uart_rx_buffer.size   = rx_buffer_size;
 1e8:	02000713          	li	a4,32
 1ec:	c3d8                	sw	a4,4(a5)
	_uart_rx_buffer.mask   = rx_buffer_size - 1;
 1ee:	477d                	li	a4,31
 1f0:	cb98                	sw	a4,16(a5)
	_uart_rx_buffer.head   = 0;
 1f2:	0007a423          	sw	zero,8(a5) # 20000008 <_uart_rx_buffer+0x8>
	_uart_rx_buffer.tail   = 0;
 1f6:	0007a623          	sw	zero,12(a5)
	RCC->APB2PCENR |= RCC_APB2Periph_USART1;
 1fa:	400217b7          	lui	a5,0x40021
 1fe:	4f98                	lw	a4,24(a5)
 200:	6691                	lui	a3,0x4
 202:	8f55                	or	a4,a4,a3
 204:	cf98                	sw	a4,24(a5)
	RCC->APB2PCENR |= UART_PORT_RCC | RCC_APB2Periph_AFIO;
 206:	4f98                	lw	a4,24(a5)
	UART_PORT->CFGLR &= ~(0x0F << (4 * UART_PIN_TX));
 208:	ff1006b7          	lui	a3,0xff100
 20c:	16fd                	addi	a3,a3,-1 # ff0fffff <__global_pointer$+0xdf0ff7ff>
	RCC->APB2PCENR |= UART_PORT_RCC | RCC_APB2Periph_AFIO;
 20e:	02176713          	ori	a4,a4,33
 212:	cf98                	sw	a4,24(a5)
	UART_PORT->CFGLR &= ~(0x0F << (4 * UART_PIN_TX));
 214:	400117b7          	lui	a5,0x40011
 218:	40078793          	addi	a5,a5,1024 # 40011400 <__global_pointer$+0x20010c00>
 21c:	4398                	lw	a4,0(a5)
 21e:	30400513          	li	a0,772
 222:	8f75                	and	a4,a4,a3
 224:	c398                	sw	a4,0(a5)
	UART_PORT->CFGLR |= (GPIO_Speed_10MHz | GPIO_CNF_OUT_PP_AF) << (4 * UART_PIN_TX);	
 226:	4398                	lw	a4,0(a5)
 228:	009006b7          	lui	a3,0x900
 22c:	8f55                	or	a4,a4,a3
 22e:	c398                	sw	a4,0(a5)
	UART_PORT->CFGLR &= ~(0x0F << (4 * UART_PIN_RX));
 230:	4398                	lw	a4,0(a5)
 232:	f10006b7          	lui	a3,0xf1000
 236:	16fd                	addi	a3,a3,-1 # f0ffffff <__global_pointer$+0xd0fff7ff>
 238:	8f75                	and	a4,a4,a3
 23a:	c398                	sw	a4,0(a5)
	UART_PORT->CFGLR |= GPIO_CNF_IN_FLOATING << (4 * UART_PIN_RX);
 23c:	4398                	lw	a4,0(a5)
 23e:	040006b7          	lui	a3,0x4000
 242:	8f55                	or	a4,a4,a3
 244:	c398                	sw	a4,0(a5)
	USART1->CTLR1 = USART_Mode_Tx | USART_Mode_Rx | conf->wordlength | conf->parity;
 246:	400147b7          	lui	a5,0x40014
 24a:	4731                	li	a4,12
 24c:	80e79623          	sh	a4,-2036(a5) # 4001380c <__global_pointer$+0x2001300c>
	USART1->CTLR2 = conf->stopbits;
 250:	80079823          	sh	zero,-2032(a5)
	USART1->BRR = conf->baudrate;
 254:	1a100713          	li	a4,417
 258:	80e79423          	sh	a4,-2040(a5)
	USART1->CTLR1 |= USART_CTLR1_RXNEIE;
 25c:	80c7d703          	lhu	a4,-2036(a5)
 *
 * @return  none
 */
RV_STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->IENR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));
 260:	4685                	li	a3,1
 262:	02076713          	ori	a4,a4,32
 266:	80e79623          	sh	a4,-2036(a5)
 26a:	e000e737          	lui	a4,0xe000e
 26e:	10d72223          	sw	a3,260(a4) # e000e104 <__global_pointer$+0xc000d904>
	USART1->CTLR1 |= CTLR1_UE_Set;
 272:	80c7d703          	lhu	a4,-2036(a5)
 276:	6689                	lui	a3,0x2
 278:	8f55                	or	a4,a4,a3
 27a:	80e79623          	sh	a4,-2036(a5)
	if(string != NULL)
 27e:	350d                	jal	a0 <uart_print.part.0>
 280:	32400513          	li	a0,804
 284:	3d31                	jal	a0 <uart_print.part.0>
	return ret_err;
 286:	3d3d                	jal	c4 <uart_println.part.0>
	if(string != NULL)
 288:	35000513          	li	a0,848
 28c:	3d11                	jal	a0 <uart_print.part.0>
	return ret_err;
 28e:	3d1d                	jal	c4 <uart_println.part.0>
	uint32_t targend = SysTick->CNT + n;
 290:	004947b7          	lui	a5,0x494
 294:	e000f637          	lui	a2,0xe000f
 298:	e0078793          	addi	a5,a5,-512 # 493e00 <lib_uart.c.4f521083+0x491cc5>
 29c:	4614                	lw	a3,8(a2)
 29e:	96be                	add	a3,a3,a5
	while( ((int32_t)( SysTick->CNT - targend )) < 0 );
 2a0:	4618                	lw	a4,8(a2)
 2a2:	8f15                	sub	a4,a4,a3
 2a4:	fe074ee3          	bltz	a4,2a0 <main+0xd0>
 2a8:	bfd5                	j	29c <main+0xcc>

000002aa <USART1_IRQHandler>:
{
 2aa:	1121                	addi	sp,sp,-24
 2ac:	c03e                	sw	a5,0(sp)
		uint8_t recv = (uint8_t)USART1->DATAR;
 2ae:	400147b7          	lui	a5,0x40014
{
 2b2:	c632                	sw	a2,12(sp)
		uint8_t recv = (uint8_t)USART1->DATAR;
 2b4:	8047d603          	lhu	a2,-2044(a5) # 40013804 <__global_pointer$+0x20013004>
		size_t next_head = (_uart_rx_buffer.head + 1) & _uart_rx_buffer.mask;
 2b8:	200007b7          	lui	a5,0x20000
{
 2bc:	c436                	sw	a3,8(sp)
		size_t next_head = (_uart_rx_buffer.head + 1) & _uart_rx_buffer.mask;
 2be:	00078693          	mv	a3,a5
{
 2c2:	c82e                	sw	a1,16(sp)
		size_t next_head = (_uart_rx_buffer.head + 1) & _uart_rx_buffer.mask;
 2c4:	468c                	lw	a1,8(a3)
{
 2c6:	ca2a                	sw	a0,20(sp)
		size_t next_head = (_uart_rx_buffer.head + 1) & _uart_rx_buffer.mask;
 2c8:	4a88                	lw	a0,16(a3)
		if(next_head == _uart_rx_buffer.tail) 
 2ca:	46d4                	lw	a3,12(a3)
{
 2cc:	c23a                	sw	a4,4(sp)
		size_t next_head = (_uart_rx_buffer.head + 1) & _uart_rx_buffer.mask;
 2ce:	00158713          	addi	a4,a1,1
 2d2:	8f69                	and	a4,a4,a0
		uint8_t recv = (uint8_t)USART1->DATAR;
 2d4:	0ff67613          	zext.b	a2,a2
		if(next_head == _uart_rx_buffer.tail) 
 2d8:	00078793          	mv	a5,a5
 2dc:	00e69663          	bne	a3,a4,2e8 <USART1_IRQHandler+0x3e>
				 _uart_rx_buffer.tail = (_uart_rx_buffer.tail + 1) & _uart_rx_buffer.mask;
 2e0:	00170693          	addi	a3,a4,1
 2e4:	8ee9                	and	a3,a3,a0
 2e6:	c7d4                	sw	a3,12(a5)
		_uart_rx_buffer.buffer[_uart_rx_buffer.head] = recv;
 2e8:	4394                	lw	a3,0(a5)
		_uart_rx_buffer.head = next_head;
 2ea:	c798                	sw	a4,8(a5)
		_uart_rx_buffer.buffer[_uart_rx_buffer.head] = recv;
 2ec:	96ae                	add	a3,a3,a1
 2ee:	00c68023          	sb	a2,0(a3) # 2000 <uarttest.c.fe5863ff+0x23d>
}
 2f2:	4552                	lw	a0,20(sp)
 2f4:	45c2                	lw	a1,16(sp)
 2f6:	4632                	lw	a2,12(sp)
 2f8:	46a2                	lw	a3,8(sp)
 2fa:	4712                	lw	a4,4(sp)
 2fc:	4782                	lw	a5,0(sp)
 2fe:	0161                	addi	sp,sp,24
 300:	30200073          	mret
 304:	6854                	.insn	2, 0x6854
 306:	7369                	lui	t1,0xffffa
 308:	7320                	.insn	2, 0x7320
 30a:	7274                	.insn	2, 0x7274
 30c:	6e69                	lui	t3,0x1a
 30e:	69772067          	.insn	4, 0x69772067
 312:	6c6c                	.insn	2, 0x6c6c
 314:	6220                	.insn	2, 0x6220
 316:	2065                	jal	3be <_data_lma+0x4a>
 318:	20656e6f          	jal	t3,5651e <lib_uart.c.4f521083+0x543e3>
 31c:	696c                	.insn	2, 0x696c
 31e:	656e                	.insn	2, 0x656e
 320:	3120                	.insn	2, 0x3120
 322:	0000                	unimp
 324:	2d20                	.insn	2, 0x2d20
 326:	202d                	jal	350 <USART1_IRQHandler+0xa6>
 328:	6854                	.insn	2, 0x6854
 32a:	7369                	lui	t1,0xffffa
 32c:	7320                	.insn	2, 0x7320
 32e:	7274                	.insn	2, 0x7274
 330:	6e69                	lui	t3,0x1a
 332:	69772067          	.insn	4, 0x69772067
 336:	6c6c                	.insn	2, 0x6c6c
 338:	6220                	.insn	2, 0x6220
 33a:	2065                	jal	3e2 <_data_lma+0x6e>
 33c:	74206e6f          	jal	t3,6a7e <lib_uart.c.4f521083+0x4943>
 340:	6568                	.insn	2, 0x6568
 342:	7320                	.insn	2, 0x7320
 344:	6d61                	lui	s10,0x18
 346:	2065                	jal	3ee <_data_lma+0x7a>
 348:	696c                	.insn	2, 0x696c
 34a:	656e                	.insn	2, 0x656e
 34c:	0000                	unimp
 34e:	0000                	unimp
 350:	6854                	.insn	2, 0x6854
 352:	7369                	lui	t1,0xffffa
 354:	7320                	.insn	2, 0x7320
 356:	7274                	.insn	2, 0x7274
 358:	6e69                	lui	t3,0x1a
 35a:	69772067          	.insn	4, 0x69772067
 35e:	6c6c                	.insn	2, 0x6c6c
 360:	6220                	.insn	2, 0x6220
 362:	2065                	jal	40a <_data_lma+0x96>
 364:	69206e6f          	jal	t3,69f6 <lib_uart.c.4f521083+0x48bb>
 368:	7374                	.insn	2, 0x7374
 36a:	6f20                	.insn	2, 0x6f20
 36c:	6c206e77          	.insn	4, 0x6c206e77
 370:	6e69                	lui	t3,0x1a
 372:	0065                	c.nop	25
